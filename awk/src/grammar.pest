// 
// Copyright (c) 2024 Hemi Labs, Inc.
// 
// This file is part of the posixutils-rs project covered under
// the MIT License.  For the full license text, please see the LICENSE
// file in the root directory of this project.
// SPDX-License-Identifier: MIT
// 

WHITESPACE = _{ " " | "\t" | "\r" }
COMMENT    = _{ "#" ~ (!"\n" ~ ANY)* ~ &"\n" }

string          =  { "\"" ~ (("\\\"") | (!("\"" | "\n") ~ ANY))* ~ "\"" }
ere             =  { "/" ~ (("\\" ~ "/") | (!("/" | "\n") ~ ANY))* ~ "/" }
number          = @{ decimal_float | integer }
digit           =  { ('0'..'9') }
integer         = @{ digit+ }
decimal_float   =  { (fractional_part ~ exponent? ~ float_suffix?) | (integer ~ exponent ~ float_suffix?) }
fractional_part =  { (integer? ~ "." ~ integer) | integer ~ "." }
exponent        =  { ("e" | "E") ~ sign? ~ integer }
sign            =  { "+" | "-" }
float_suffix    =  { "f" | "l" | "F" | "L" }

letter    =  { ('a'..'z') | ('A'..'Z') }
name      = @{ !(keyword | builtin_func) ~ (letter | "_") ~ (letter | "_" | digit)* }
func_name = @{ !(keyword | builtin_func) ~ name ~ &"(" }

builtin_func = {
    atan2
  | cos
  | sin
  | exp
  | log
  | sqrt
  | int
  | rand
  | srand
  | gsub
  | index
  | length
  | match
  | split
  | sprintf
  | sub
  | substr
  | tolower
  | toupper
  | close
  | system
}

atan2   = { "atan2" }
cos     = { "cos" }
sin     = { "sin" }
exp     = { "exp" }
log     = { "log" }
sqrt    = { "sqrt" }
int     = { "int" }
rand    = { "rand" }
srand   = { "srand" }
gsub    = { "gsub" }
index   = { "index" }
length  = { "length" }
match   = { "match" }
split   = { "split" }
sprintf = { "sprintf" }
sub     = { "sub" }
substr  = { "substr" }
tolower = { "tolower" }
toupper = { "toupper" }
close   = { "close" }
system  = { "system" }

keyword = {
    "if"
  | "else"
  | "while"
  | "for"
  | "foreach"
  | "next"
  | "break"
  | "continue"
  | "do"
  | "return"
  | "exit"
  | "print"
  | "printf"
  | "in"
  | "begin"
  | "end"
  | "function"
}

program = { SOI ~ opt_newline ~ (item ~ terminator)* ~ item? ~ EOI }

terminator = _{ ";"? ~ "\n"* }

opt_newline = _{ "\n"* }

item = _{
    begin_action
  | end_action
  | rule
  | function_definition
}

begin_action = { "BEGIN" ~ action }
end_action   = { "END" ~ action }

rule = {
    action
  | pattern_and_action
  | normal_pattern
}

pattern_and_action = {
    normal_pattern ~ action
}

function_definition = { "function" ~ name ~ "(" ~ param_list? ~ ")" ~ opt_newline ~ action }

param_list = { name ~ ("," ~ name)* }

normal_pattern = { expr | (expr ~ "," ~ opt_newline ~ expr) }

action = {
    "{" ~ opt_newline ~ "}"
  | "{" ~ opt_newline ~ terminated_statement* ~ unterminated_statement? ~ "}"
}

terminated_statement = _{
    action ~ opt_newline
  | t_if
  | t_while
  | t_for
  | t_foreach
  | empty_stmt
  | terminatable_statement ~ "\n" ~ opt_newline
  | terminatable_statement ~ ";" ~ opt_newline
}

t_if       =  { "if" ~ "(" ~ expr ~ ")" ~ opt_newline ~ terminated_statement ~ ("else" ~ opt_newline ~ terminated_statement)? }
t_while    =  { "while" ~ "(" ~ expr ~ ")" ~ opt_newline ~ terminated_statement }
t_for      =  { "for" ~ "(" ~ simple_statement? ~ ";" ~ expr? ~ ";" ~ simple_statement? ~ ")" ~ opt_newline ~ terminated_statement }
t_foreach  =  { "for" ~ "(" ~ name ~ "in" ~ name ~ ")" ~ opt_newline ~ terminated_statement }
empty_stmt = _{ ";" ~ opt_newline }

unterminated_statement = _{
    terminatable_statement
  | ut_if
  | ut_while
  | ut_for
  | ut_foreach
}

ut_if      = { "if" ~ "(" ~ expr ~ ")" ~ opt_newline ~ (unterminated_statement | terminated_statement ~ "else" ~ opt_newline ~ unterminated_statement) }
ut_while   = { "while" ~ "(" ~ expr ~ ")" ~ opt_newline ~ unterminated_statement }
ut_for     = { "for" ~ "(" ~ simple_statement? ~ ";" ~ expr? ~ ";" ~ simple_statement? ~ ")" ~ opt_newline ~ unterminated_statement }
ut_foreach = { "for" ~ "(" ~ name ~ in_op ~ name ~ ")" ~ opt_newline ~ unterminated_statement }

terminatable_statement = _{
    simple_statement
  | next
  | break_stmt
  | continue_stmt
  | exit_stmt
  | return_stmt
  | do_while
}

do_while      = { "do" ~ opt_newline ~ terminated_statement ~ "while" ~ "(" ~ expr ~ ")" }
next          = { "next" }
break_stmt    = { "break" }
continue_stmt = { "continue" }

return_stmt = { "return" ~ expr? }
exit_stmt   = { "exit" ~ expr? }

simple_statement = {
    delete_element
  | expr
  | print_stmt
}

delete_element = {
    "delete" ~ name ~ "[" ~ expr ~ "]"
}

print_stmt = {
    (print_call | simple_print | printf_call | simple_printf) ~ output_redirection?
}

simple_print       = { "print" ~ print_expr_list? }
print_call         = { "print" ~ "(" ~ multiple_expr_list ~ ")" }
simple_printf      = { "printf" ~ print_expr_list? }
printf_call        = { "printf" ~ "(" ~ multiple_expr_list ~ ")" }
output_redirection = {
    ">" ~ expr
  | ">>" ~ expr
  | "|" ~ expr
}

print_expr_list    = { print_expr ~ ("," ~ opt_newline ~ print_expr)* }
expr_list          = { expr | multiple_expr_list }
multiple_expr_list = { expr ~ ("," ~ opt_newline ~ expr)+ }

primary = _{
    "(" ~ expr ~ ")"
  | ere
  | number
  | string
  | array_element
  | name
  | func_name ~ "(" ~ expr_list? ~ ")"
  | builtin_func ~ "(" ~ expr_list? ~ ")"
  | builtin_func
}

array_element = { name ~ "[" ~ expr_list ~ "]" }

prefix_op = _{
    dollarsign
  | pre_inc
  | pre_dec
  | not
  | unary_plus
  | negate
}

dollarsign = { "$" }
pre_inc    = { "++" }
pre_dec    = { "--" }
not        = { "!" }
unary_plus = { "+" }
negate     = { "-" }

postfix_op = _{
    post_inc
  | post_dec
}

post_inc = { "++" }
post_dec = { "--" }

infix_op = _{
    pow
  | mul
  | div
  | modulus
  | add
  | binary_sub
  | comp_op
  | match_op
  | not_match
  | in_op
  | and
  | or
  | concat
}

pow        = { "^" }
mul        = { "*" }
div        = { "/" }
modulus    = { "%" }
add        = { "+" }
binary_sub = { "-" }
match_op   = { "~" }
not_match  = { "!~" }
and        = { "&&" }
or         = { "||" }
concat     = { "" }
in_op      = { "in" }

comp_op = {
    le
  | lt
  | ge
  | gt
  | ne
  | eq
}

lt = { "<" }
le = { "<=" }
ne = { "!=" }
eq = { "==" }
gt = { ">" }
ge = { ">=" }

binary_expr = { prefix_op? ~ primary ~ postfix_op? ~ (infix_op ~ prefix_op? ~ primary ~ postfix_op?)* }

ternary_expr = { binary_expr ~ "?" ~ expr ~ ":" ~ expr }

assignment = { lvalue ~ assignment_op ~ expr }

assignment_op = {
    assign
  | add_assign
  | sub_assign
  | mul_assign
  | div_assign
  | mod_assign
  | pow_assign
}

assign     = { "=" }
add_assign = { "+=" }
sub_assign = { "-=" }
mul_assign = { "*=" }
div_assign = { "/=" }
mod_assign = { "%=" }
pow_assign = { "^=" }

expr = {
    assignment
  | ternary_expr
  | binary_expr
  | input_function
}

lvalue = _{
    array_element
  | name
  | "$" ~ expr
}

input_function = {
    simple_get
  | simple_get ~ "<" ~ expr
  | "|" ~ "getline" ~ lvalue?
}

simple_get = { "getline" ~ lvalue? }

print_infix_op = _{
    pow
  | mul
  | div
  | modulus
  | add
  | binary_sub
  | match_op
  | not_match
  | in_op
  | and
  | or
  | concat
}

binary_print_expr  = { prefix_op? ~ primary ~ postfix_op? ~ (print_infix_op ~ prefix_op? ~ primary ~ postfix_op?)* }
print_assignment   = { lvalue ~ assignment_op ~ print_expr }
ternary_print_expr = { binary_print_expr ~ "?" ~ print_expr ~ ":" ~ print_expr }

print_expr = {
    assignment
  | ternary_print_expr
  | binary_print_expr
}
